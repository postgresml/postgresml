/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/

-- src/bindings/xgboost.rs:19
-- pgml::bindings::xgboost::xgboost_version
DROP FUNCTION IF EXISTS pgml."xgboost_version"();
CREATE  FUNCTION pgml."xgboost_version"() RETURNS TEXT /* alloc::string::String */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'xgboost_version_wrapper';

-- src/api.rs:109
-- pgml::api::version
DROP FUNCTION IF EXISTS pgml."version"();
CREATE  FUNCTION pgml."version"() RETURNS TEXT /* alloc::string::String */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'version_wrapper';

-- src/api.rs:73
-- pgml::api::validate_shared_library
DROP FUNCTION IF EXISTS pgml."validate_shared_library"();
CREATE  FUNCTION pgml."validate_shared_library"() RETURNS void
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'validate_shared_library_wrapper';

-- src/api.rs:25
-- pgml::api::validate_python_dependencies
DROP FUNCTION IF EXISTS pgml."validate_python_dependencies"();
CREATE  FUNCTION pgml."validate_python_dependencies"() RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'validate_python_dependencies_wrapper';

-- src/api.rs:586
-- pgml::api::transform
DROP FUNCTION IF EXISTS pgml."transform"(TEXT, jsonb, TEXT[], bool);
CREATE  FUNCTION pgml."transform"(
	"task" TEXT, /* alloc::string::String */
	"args" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"inputs" TEXT[] DEFAULT ARRAY[]::TEXT[], /* alloc::vec::Vec<alloc::string::String> */
	"cache" bool DEFAULT false /* bool */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'transform_string_wrapper';

-- src/api.rs:573
-- pgml::api::transform
DROP FUNCTION IF EXISTS pgml."transform"(jsonb, jsonb, TEXT[], bool);
CREATE  FUNCTION pgml."transform"(
	"task" jsonb, /* pgrx::datum::json::JsonB */
	"args" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"inputs" TEXT[] DEFAULT ARRAY[]::TEXT[], /* alloc::vec::Vec<alloc::string::String> */
	"cache" bool DEFAULT false /* bool */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'transform_json_wrapper';

DROP AGGREGATE IF EXISTS pgml."sum"(real[]);

-- src/vectors.rs:336
-- pgml::vectors::sum_s_state
DROP FUNCTION IF EXISTS pgml."sum_s_state"(real[], real[]);
CREATE  FUNCTION pgml."sum_s_state"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"arg_one" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_s_state_wrapper';

-- src/vectors.rs:336
-- pgml::vectors::sum_s_finalize
DROP FUNCTION IF EXISTS pgml."sum_s_finalize"(real[]);
CREATE  FUNCTION pgml."sum_s_finalize"(
	"this" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_s_finalize_wrapper';

-- src/vectors.rs:336
-- pgml::vectors::sum_s_combine
DROP FUNCTION IF EXISTS pgml."sum_s_combine"(real[], real[]);
CREATE  FUNCTION pgml."sum_s_combine"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"v" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_s_combine_wrapper';

-- src/vectors.rs:336
-- pgml::vectors::SumS
CREATE AGGREGATE pgml.sum (
	real[] /* core::option::Option<alloc::vec::Vec<f32>> */
)
(
	SFUNC = pgml."sum_s_state", /* pgml::vectors::SumS::state */
	STYPE = real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	FINALFUNC = pgml."sum_s_finalize", /* pgml::vectors::SumS::final */
	COMBINEFUNC = pgml."sum_s_combine" /* pgml::vectors::SumS::combine */
);

DROP AGGREGATE IF EXISTS pgml."sum"(double precision[]);

-- src/vectors.rs:399
-- pgml::vectors::sum_d_state
DROP FUNCTION IF EXISTS pgml."sum_d_state"(double precision[], double precision[]);
CREATE  FUNCTION pgml."sum_d_state"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"arg_one" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_d_state_wrapper';

-- src/vectors.rs:399
-- pgml::vectors::sum_d_finalize
DROP FUNCTION IF EXISTS pgml."sum_d_finalize"(double precision[]);
CREATE  FUNCTION pgml."sum_d_finalize"(
	"this" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_d_finalize_wrapper';

-- src/vectors.rs:399
-- pgml::vectors::sum_d_combine
DROP FUNCTION IF EXISTS pgml."sum_d_combine"(double precision[], double precision[]);
CREATE  FUNCTION pgml."sum_d_combine"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"v" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sum_d_combine_wrapper';

-- src/vectors.rs:399
-- pgml::vectors::SumD
CREATE AGGREGATE pgml.sum (
	double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
)
(
	SFUNC = pgml."sum_d_state", /* pgml::vectors::SumD::state */
	STYPE = double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	FINALFUNC = pgml."sum_d_finalize", /* pgml::vectors::SumD::final */
	COMBINEFUNC = pgml."sum_d_combine" /* pgml::vectors::SumD::combine */
);

-- src/vectors.rs:64
-- pgml::vectors::subtract
DROP FUNCTION IF EXISTS pgml."subtract"(real[], real[]);
CREATE  FUNCTION pgml."subtract"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"subtahend" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'subtract_vector_s_wrapper';

-- src/vectors.rs:74
-- pgml::vectors::subtract
DROP FUNCTION IF EXISTS pgml."subtract"(double precision[], double precision[]);
CREATE  FUNCTION pgml."subtract"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"subtahend" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'subtract_vector_d_wrapper';

-- src/vectors.rs:14
-- pgml::vectors::subtract
DROP FUNCTION IF EXISTS pgml."subtract"(real[], real);
CREATE  FUNCTION pgml."subtract"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"subtahend" real /* f32 */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'subtract_scalar_s_wrapper';

-- src/vectors.rs:19
-- pgml::vectors::subtract
DROP FUNCTION IF EXISTS pgml."subtract"(double precision[], double precision);
CREATE  FUNCTION pgml."subtract"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"subtahend" double precision /* f64 */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'subtract_scalar_d_wrapper';

-- src/api.rs:811
-- pgml::api::sklearn_regression_metrics
DROP FUNCTION IF EXISTS pgml."sklearn_regression_metrics"(real[], real[]);
CREATE  FUNCTION pgml."sklearn_regression_metrics"(
	"ground_truth" real[], /* alloc::vec::Vec<f32> */
	"y_hat" real[] /* alloc::vec::Vec<f32> */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sklearn_regression_metrics_wrapper';

-- src/api.rs:805
-- pgml::api::sklearn_r2_score
DROP FUNCTION IF EXISTS pgml."sklearn_r2_score"(real[], real[]);
CREATE  FUNCTION pgml."sklearn_r2_score"(
	"ground_truth" real[], /* alloc::vec::Vec<f32> */
	"y_hat" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sklearn_r2_score_wrapper';

-- src/api.rs:799
-- pgml::api::sklearn_f1_score
DROP FUNCTION IF EXISTS pgml."sklearn_f1_score"(real[], real[]);
CREATE  FUNCTION pgml."sklearn_f1_score"(
	"ground_truth" real[], /* alloc::vec::Vec<f32> */
	"y_hat" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sklearn_f1_score_wrapper';

-- src/api.rs:826
-- pgml::api::sklearn_classification_metrics
DROP FUNCTION IF EXISTS pgml."sklearn_classification_metrics"(real[], real[], bigint);
CREATE  FUNCTION pgml."sklearn_classification_metrics"(
	"ground_truth" real[], /* alloc::vec::Vec<f32> */
	"y_hat" real[], /* alloc::vec::Vec<f32> */
	"num_classes" bigint /* i64 */
) RETURNS jsonb /* pgrx::datum::json::JsonB */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'sklearn_classification_metrics_wrapper';

-- src/api.rs:90
-- pgml::api::python_version
DROP FUNCTION IF EXISTS pgml."python_version"();
CREATE  FUNCTION pgml."python_version"() RETURNS TEXT /* alloc::string::String */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'python_version_wrapper';

-- src/api.rs:61
-- pgml::api::python_package_version
DROP FUNCTION IF EXISTS pgml."python_package_version"(TEXT);
CREATE  FUNCTION pgml."python_package_version"(
	"name" TEXT /* &str */
) RETURNS TEXT /* alloc::string::String */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'python_package_version_wrapper';

-- src/api.rs:460
-- pgml::api::predict_proba
DROP FUNCTION IF EXISTS pgml."predict_proba"(TEXT, real[]);
CREATE  FUNCTION pgml."predict_proba"(
	"project_name" TEXT, /* &str */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_proba_wrapper';

-- src/api.rs:487
-- pgml::api::predict_proba
DROP FUNCTION IF EXISTS pgml."predict_proba"(bigint, real[]);
CREATE  FUNCTION pgml."predict_proba"(
	"model_id" bigint, /* i64 */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_model_proba_wrapper';

-- src/api.rs:492
-- pgml::api::predict_joint
DROP FUNCTION IF EXISTS pgml."predict_joint"(bigint, real[]);
CREATE  FUNCTION pgml."predict_joint"(
	"model_id" bigint, /* i64 */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_model_joint_wrapper';

-- src/api.rs:465
-- pgml::api::predict_joint
DROP FUNCTION IF EXISTS pgml."predict_joint"(TEXT, real[]);
CREATE  FUNCTION pgml."predict_joint"(
	"project_name" TEXT, /* &str */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_joint_wrapper';

-- src/api.rs:497
-- pgml::api::predict_batch
DROP FUNCTION IF EXISTS pgml."predict_batch"(bigint, real[]);
CREATE  FUNCTION pgml."predict_batch"(
	"model_id" bigint, /* i64 */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_model_batch_wrapper';

-- src/api.rs:470
-- pgml::api::predict_batch
DROP FUNCTION IF EXISTS pgml."predict_batch"(TEXT, real[]);
CREATE  FUNCTION pgml."predict_batch"(
	"project_name" TEXT, /* &str */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS SETOF real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_batch_wrapper';

-- src/api.rs:477
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(TEXT, anyelement);
CREATE  FUNCTION pgml."predict"(
	"project_name" TEXT, /* &str */
	"row" anyelement /* pgrx::datum::anyelement::AnyElement */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_row_wrapper';

-- src/api.rs:502
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(bigint, anyelement);
CREATE  FUNCTION pgml."predict"(
	"model_id" bigint, /* i64 */
	"row" anyelement /* pgrx::datum::anyelement::AnyElement */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_model_row_wrapper';

-- src/api.rs:482
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(bigint, real[]);
CREATE  FUNCTION pgml."predict"(
	"model_id" bigint, /* i64 */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_model_wrapper';

-- src/api.rs:447
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(TEXT, bigint[]);
CREATE  FUNCTION pgml."predict"(
	"project_name" TEXT, /* &str */
	"features" bigint[] /* alloc::vec::Vec<i64> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_i64_wrapper';

-- src/api.rs:442
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(TEXT, INT[]);
CREATE  FUNCTION pgml."predict"(
	"project_name" TEXT, /* &str */
	"features" INT[] /* alloc::vec::Vec<i32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_i32_wrapper';

-- src/api.rs:437
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(TEXT, smallint[]);
CREATE  FUNCTION pgml."predict"(
	"project_name" TEXT, /* &str */
	"features" smallint[] /* alloc::vec::Vec<i16> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_i16_wrapper';

-- src/api.rs:432
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(TEXT,  double precision[]);
CREATE  FUNCTION pgml."predict"(
	"project_name" TEXT, /* &str */
	"features" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_f64_wrapper';

-- src/api.rs:427
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(TEXT, real[]);
CREATE  FUNCTION pgml."predict"(
	"project_name" TEXT, /* &str */
	"features" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_f32_wrapper';

-- src/api.rs:452
-- pgml::api::predict
DROP FUNCTION IF EXISTS pgml."predict"(TEXT, bool[]);
CREATE  FUNCTION pgml."predict"(
	"project_name" TEXT, /* &str */
	"features" bool[] /* alloc::vec::Vec<bool> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'predict_bool_wrapper';

-- src/vectors.rs:214
-- pgml::vectors::normalize_max
DROP FUNCTION IF EXISTS pgml."normalize_max"(real[]);
CREATE  FUNCTION pgml."normalize_max"(
	"vector" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'normalize_max_s_wrapper';

-- src/vectors.rs:224
-- pgml::vectors::normalize_max
DROP FUNCTION IF EXISTS pgml."normalize_max"(double precision[]);
CREATE  FUNCTION pgml."normalize_max"(
	"vector" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'normalize_max_d_wrapper';

-- src/vectors.rs:196
-- pgml::vectors::normalize_l2
DROP FUNCTION IF EXISTS pgml."normalize_l2"(real[]);
CREATE  FUNCTION pgml."normalize_l2"(
	"vector" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'normalize_l2_s_wrapper';

-- src/vectors.rs:205
-- pgml::vectors::normalize_l2
DROP FUNCTION IF EXISTS pgml."normalize_l2"(double precision[]);
CREATE  FUNCTION pgml."normalize_l2"(
	"vector" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'normalize_l2_d_wrapper';

-- src/vectors.rs:178
-- pgml::vectors::normalize_l1
DROP FUNCTION IF EXISTS pgml."normalize_l1"(real[]);
CREATE  FUNCTION pgml."normalize_l1"(
	"vector" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'normalize_l1_s_wrapper';

-- src/vectors.rs:187
-- pgml::vectors::normalize_l1
DROP FUNCTION IF EXISTS pgml."normalize_l1"(double precision[]);
CREATE  FUNCTION pgml."normalize_l1"(
	"vector" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'normalize_l1_d_wrapper';

-- src/vectors.rs:162
-- pgml::vectors::norm_max
DROP FUNCTION IF EXISTS pgml."norm_max"(real[]);
CREATE  FUNCTION pgml."norm_max"(
	"vector" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_max_s_wrapper';

-- src/vectors.rs:170
-- pgml::vectors::norm_max
DROP FUNCTION IF EXISTS pgml."norm_max"(double precision[]);
CREATE  FUNCTION pgml."norm_max"(
	"vector" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_max_d_wrapper';

-- src/vectors.rs:152
-- pgml::vectors::norm_l2
DROP FUNCTION IF EXISTS pgml."norm_l2"(real[]);
CREATE  FUNCTION pgml."norm_l2"(
	"vector" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_l2_s_wrapper';

-- src/vectors.rs:157
-- pgml::vectors::norm_l2
DROP FUNCTION IF EXISTS pgml."norm_l2"(double precision[]);
CREATE  FUNCTION pgml."norm_l2"(
	"vector" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_l2_d_wrapper';

-- src/vectors.rs:142
-- pgml::vectors::norm_l1
DROP FUNCTION IF EXISTS pgml."norm_l1"(real[]);
CREATE  FUNCTION pgml."norm_l1"(
	"vector" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_l1_s_wrapper';

-- src/vectors.rs:147
-- pgml::vectors::norm_l1
DROP FUNCTION IF EXISTS pgml."norm_l1"(double precision[]);
CREATE  FUNCTION pgml."norm_l1"(
	"vector" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_l1_d_wrapper';

-- src/vectors.rs:124
-- pgml::vectors::norm_l0
DROP FUNCTION IF EXISTS pgml."norm_l0"(real[]);
CREATE  FUNCTION pgml."norm_l0"(
	"vector" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_l0_s_wrapper';

-- src/vectors.rs:133
-- pgml::vectors::norm_l0
DROP FUNCTION IF EXISTS pgml."norm_l0"(double precision[]);
CREATE  FUNCTION pgml."norm_l0"(
	"vector" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'norm_l0_d_wrapper';

-- src/vectors.rs:84
-- pgml::vectors::multiply
DROP FUNCTION IF EXISTS pgml."multiply"(real[], real[]);
CREATE  FUNCTION pgml."multiply"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"multiplicand" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'multiply_vector_s_wrapper';

-- src/vectors.rs:94
-- pgml::vectors::multiply
DROP FUNCTION IF EXISTS pgml."multiply"(double precision[], double precision[]);
CREATE  FUNCTION pgml."multiply"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"multiplicand" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'multiply_vector_d_wrapper';

-- src/vectors.rs:24
-- pgml::vectors::multiply
DROP FUNCTION IF EXISTS pgml."multiply"(real[], real);
CREATE  FUNCTION pgml."multiply"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"multiplicand" real /* f32 */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'multiply_scalar_s_wrapper';

-- src/vectors.rs:29
-- pgml::vectors::multiply
DROP FUNCTION IF EXISTS pgml."multiply"(double precision[], double precision);
CREATE  FUNCTION pgml."multiply"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"multiplicand" double precision /* f64 */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'multiply_scalar_d_wrapper';

DROP AGGREGATE IF EXISTS pgml."min"(real[]);

-- src/vectors.rs:730
-- pgml::vectors::min_s_state
DROP FUNCTION IF EXISTS pgml."min_s_state"(real[], real[]);
CREATE  FUNCTION pgml."min_s_state"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"arg_one" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_s_state_wrapper';

-- src/vectors.rs:730
-- pgml::vectors::min_s_finalize
DROP FUNCTION IF EXISTS pgml."min_s_finalize"(real[]);
CREATE  FUNCTION pgml."min_s_finalize"(
	"this" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_s_finalize_wrapper';

-- src/vectors.rs:730
-- pgml::vectors::min_s_combine
DROP FUNCTION IF EXISTS pgml."min_s_combine"(real[], real[]);
CREATE  FUNCTION pgml."min_s_combine"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"v" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_s_combine_wrapper';

-- src/vectors.rs:730
-- pgml::vectors::MinS
CREATE AGGREGATE pgml.min (
	real[] /* core::option::Option<alloc::vec::Vec<f32>> */
)
(
	SFUNC = pgml."min_s_state", /* pgml::vectors::MinS::state */
	STYPE = real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	FINALFUNC = pgml."min_s_finalize", /* pgml::vectors::MinS::final */
	COMBINEFUNC = pgml."min_s_combine" /* pgml::vectors::MinS::combine */
);

DROP AGGREGATE IF EXISTS pgml."min"(double precision[]);

-- src/vectors.rs:797
-- pgml::vectors::min_d_state
DROP FUNCTION IF EXISTS pgml."min_d_state"(double precision[], double precision[]);
CREATE  FUNCTION pgml."min_d_state"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"arg_one" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_d_state_wrapper';

-- src/vectors.rs:797
-- pgml::vectors::min_d_finalize
DROP FUNCTION IF EXISTS pgml."min_d_finalize"(double precision[]);
CREATE  FUNCTION pgml."min_d_finalize"(
	"this" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_d_finalize_wrapper';

-- src/vectors.rs:797
-- pgml::vectors::min_d_combine
DROP FUNCTION IF EXISTS pgml."min_d_combine"(double precision[], double precision[]);
CREATE  FUNCTION pgml."min_d_combine"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"v" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_d_combine_wrapper';

-- src/vectors.rs:797
-- pgml::vectors::MinD
CREATE AGGREGATE pgml.min (
	double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
)
(
	SFUNC = pgml."min_d_state", /* pgml::vectors::MinD::state */
	STYPE = double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	FINALFUNC = pgml."min_d_finalize", /* pgml::vectors::MinD::final */
	COMBINEFUNC = pgml."min_d_combine" /* pgml::vectors::MinD::combine */
);

DROP AGGREGATE IF EXISTS pgml."min_abs"(real[]);

-- src/vectors.rs:864
-- pgml::vectors::min_abs_s_state
DROP FUNCTION IF EXISTS pgml."min_abs_s_state"(real[], real[]);
CREATE  FUNCTION pgml."min_abs_s_state"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"arg_one" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_abs_s_state_wrapper';

-- src/vectors.rs:864
-- pgml::vectors::min_abs_s_finalize
DROP FUNCTION IF EXISTS pgml."min_abs_s_finalize"(real[]);
CREATE  FUNCTION pgml."min_abs_s_finalize"(
	"this" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_abs_s_finalize_wrapper';

-- src/vectors.rs:864
-- pgml::vectors::min_abs_s_combine
DROP FUNCTION IF EXISTS pgml."min_abs_s_combine"(real[], real[]);
CREATE  FUNCTION pgml."min_abs_s_combine"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"v" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_abs_s_combine_wrapper';

-- src/vectors.rs:864
-- pgml::vectors::MinAbsS
CREATE AGGREGATE pgml.min_abs (
	real[] /* core::option::Option<alloc::vec::Vec<f32>> */
)
(
	SFUNC = pgml."min_abs_s_state", /* pgml::vectors::MinAbsS::state */
	STYPE = real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	FINALFUNC = pgml."min_abs_s_finalize", /* pgml::vectors::MinAbsS::final */
	COMBINEFUNC = pgml."min_abs_s_combine" /* pgml::vectors::MinAbsS::combine */
);

DROP AGGREGATE IF EXISTS pgml."min_abs"(double precision[]);

-- src/vectors.rs:931
-- pgml::vectors::min_abs_d_state
DROP FUNCTION IF EXISTS pgml."min_abs_d_state"(double precision[], double precision[]);
CREATE  FUNCTION pgml."min_abs_d_state"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"arg_one" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_abs_d_state_wrapper';

-- src/vectors.rs:931
-- pgml::vectors::min_abs_d_finalize
DROP FUNCTION IF EXISTS pgml."min_abs_d_finalize"(double precision[]);
CREATE  FUNCTION pgml."min_abs_d_finalize"(
	"this" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_abs_d_finalize_wrapper';

-- src/vectors.rs:931
-- pgml::vectors::min_abs_d_combine
DROP FUNCTION IF EXISTS pgml."min_abs_d_combine"(double precision[], double precision[]);
CREATE  FUNCTION pgml."min_abs_d_combine"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"v" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'min_abs_d_combine_wrapper';

-- src/vectors.rs:931
-- pgml::vectors::MinAbsD
CREATE AGGREGATE pgml.min_abs (
	double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
)
(
	SFUNC = pgml."min_abs_d_state", /* pgml::vectors::MinAbsD::state */
	STYPE = double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	FINALFUNC = pgml."min_abs_d_finalize", /* pgml::vectors::MinAbsD::final */
	COMBINEFUNC = pgml."min_abs_d_combine" /* pgml::vectors::MinAbsD::combine */
);

DROP AGGREGATE IF EXISTS pgml."max"(real[]);

-- src/vectors.rs:596
-- pgml::vectors::max_s_state
DROP FUNCTION IF EXISTS pgml."max_s_state"(real[], real[]);
CREATE  FUNCTION pgml."max_s_state"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"arg_one" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_s_state_wrapper';

-- src/vectors.rs:596
-- pgml::vectors::max_s_finalize
DROP FUNCTION IF EXISTS pgml."max_s_finalize"(real[]);
CREATE  FUNCTION pgml."max_s_finalize"(
	"this" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_s_finalize_wrapper';

-- src/vectors.rs:596
-- pgml::vectors::max_s_combine
DROP FUNCTION IF EXISTS pgml."max_s_combine"(real[], real[]);
CREATE  FUNCTION pgml."max_s_combine"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"v" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_s_combine_wrapper';

-- src/vectors.rs:596
-- pgml::vectors::MaxS
CREATE AGGREGATE pgml.max (
	real[] /* core::option::Option<alloc::vec::Vec<f32>> */
)
(
	SFUNC = pgml."max_s_state", /* pgml::vectors::MaxS::state */
	STYPE = real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	FINALFUNC = pgml."max_s_finalize", /* pgml::vectors::MaxS::final */
	COMBINEFUNC = pgml."max_s_combine" /* pgml::vectors::MaxS::combine */
);

DROP AGGREGATE IF EXISTS pgml."max"(double precision[]);

-- src/vectors.rs:663
-- pgml::vectors::max_d_state
DROP FUNCTION IF EXISTS pgml."max_d_state"(double precision[], double precision[]);
CREATE  FUNCTION pgml."max_d_state"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"arg_one" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_d_state_wrapper';

-- src/vectors.rs:663
-- pgml::vectors::max_d_finalize
DROP FUNCTION IF EXISTS pgml."max_d_finalize"(double precision[]);
CREATE  FUNCTION pgml."max_d_finalize"(
	"this" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_d_finalize_wrapper';

-- src/vectors.rs:663
-- pgml::vectors::max_d_combine
DROP FUNCTION IF EXISTS pgml."max_d_combine"(double precision[], double precision[]);
CREATE  FUNCTION pgml."max_d_combine"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"v" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_d_combine_wrapper';

-- src/vectors.rs:663
-- pgml::vectors::MaxD
CREATE AGGREGATE pgml.max (
	double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
)
(
	SFUNC = pgml."max_d_state", /* pgml::vectors::MaxD::state */
	STYPE = double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	FINALFUNC = pgml."max_d_finalize", /* pgml::vectors::MaxD::final */
	COMBINEFUNC = pgml."max_d_combine" /* pgml::vectors::MaxD::combine */
);

DROP AGGREGATE IF EXISTS pgml."max_abs"(real[]);

-- src/vectors.rs:462
-- pgml::vectors::max_abs_s_state
DROP FUNCTION IF EXISTS pgml."max_abs_s_state"(real[], real[]);
CREATE  FUNCTION pgml."max_abs_s_state"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"arg_one" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_abs_s_state_wrapper';

-- src/vectors.rs:462
-- pgml::vectors::max_abs_s_finalize
DROP FUNCTION IF EXISTS pgml."max_abs_s_finalize"(real[]);
CREATE  FUNCTION pgml."max_abs_s_finalize"(
	"this" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_abs_s_finalize_wrapper';

-- src/vectors.rs:462
-- pgml::vectors::max_abs_s_combine
DROP FUNCTION IF EXISTS pgml."max_abs_s_combine"(real[], real[]);
CREATE  FUNCTION pgml."max_abs_s_combine"(
	"this" real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	"v" real[] /* core::option::Option<alloc::vec::Vec<f32>> */
) RETURNS real[] /* core::option::Option<alloc::vec::Vec<f32>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_abs_s_combine_wrapper';

-- src/vectors.rs:462
-- pgml::vectors::MaxAbsS
CREATE AGGREGATE pgml.max_abs (
	real[] /* core::option::Option<alloc::vec::Vec<f32>> */
)
(
	SFUNC = pgml."max_abs_s_state", /* pgml::vectors::MaxAbsS::state */
	STYPE = real[], /* core::option::Option<alloc::vec::Vec<f32>> */
	FINALFUNC = pgml."max_abs_s_finalize", /* pgml::vectors::MaxAbsS::final */
	COMBINEFUNC = pgml."max_abs_s_combine" /* pgml::vectors::MaxAbsS::combine */
);

DROP AGGREGATE IF EXISTS pgml."max_abs"(double precision[]);

-- src/vectors.rs:529
-- pgml::vectors::max_abs_d_state
DROP FUNCTION IF EXISTS pgml."max_abs_d_state"(double precision[], double precision[]);
CREATE  FUNCTION pgml."max_abs_d_state"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"arg_one" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_abs_d_state_wrapper';

-- src/vectors.rs:529
-- pgml::vectors::max_abs_d_finalize
DROP FUNCTION IF EXISTS pgml."max_abs_d_finalize"(double precision[]);
CREATE  FUNCTION pgml."max_abs_d_finalize"(
	"this" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_abs_d_finalize_wrapper';

-- src/vectors.rs:529
-- pgml::vectors::max_abs_d_combine
DROP FUNCTION IF EXISTS pgml."max_abs_d_combine"(double precision[], double precision[]);
CREATE  FUNCTION pgml."max_abs_d_combine"(
	"this" double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	"v" double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'max_abs_d_combine_wrapper';

-- src/vectors.rs:529
-- pgml::vectors::MaxAbsD
CREATE AGGREGATE pgml.max_abs (
	double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
)
(
	SFUNC = pgml."max_abs_d_state", /* pgml::vectors::MaxAbsD::state */
	STYPE = double precision[], /* core::option::Option<alloc::vec::Vec<f64>> */
	FINALFUNC = pgml."max_abs_d_finalize", /* pgml::vectors::MaxAbsD::final */
	COMBINEFUNC = pgml."max_abs_d_combine" /* pgml::vectors::MaxAbsD::combine */
);

-- src/api.rs:541
-- pgml::api::load_dataset
DROP FUNCTION IF EXISTS pgml."load_dataset"(TEXT, TEXT, bigint, jsonb);
CREATE  FUNCTION pgml."load_dataset"(
	"source" TEXT, /* &str */
	"subset" TEXT DEFAULT NULL, /* core::option::Option<alloc::string::String> */
	"limit" bigint DEFAULT NULL, /* core::option::Option<i64> */
	"kwargs" jsonb DEFAULT '{}' /* pgrx::datum::json::JsonB */
) RETURNS TABLE (
	"table_name" TEXT,  /* alloc::string::String */
	"rows" bigint  /* i64 */
)
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'load_dataset_wrapper';

-- src/api.rs:883
-- pgml::api::load_all
DROP FUNCTION IF EXISTS pgml."load_all"(TEXT);
CREATE  FUNCTION pgml."load_all"(
	"path" TEXT /* &str */
) RETURNS void
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'load_all_wrapper';

-- src/api.rs:611
-- pgml::api::generate
DROP FUNCTION IF EXISTS pgml."generate"(TEXT, TEXT[], jsonb);
CREATE  FUNCTION pgml."generate"(
	"project_name" TEXT, /* &str */
	"inputs" TEXT[], /* alloc::vec::Vec<&str> */
	"config" jsonb DEFAULT '{}' /* pgrx::datum::json::JsonB */
) RETURNS TEXT[] /* alloc::vec::Vec<alloc::string::String> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'generate_batch_wrapper';

-- src/api.rs:602
-- pgml::api::generate
DROP FUNCTION IF EXISTS pgml."generate"(TEXT, TEXT, jsonb);
CREATE  FUNCTION pgml."generate"(
	"project_name" TEXT, /* &str */
	"inputs" TEXT, /* &str */
	"config" jsonb DEFAULT '{}' /* pgrx::datum::json::JsonB */
) RETURNS TEXT /* alloc::string::String */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'generate_wrapper';

-- src/api.rs:567
-- pgml::api::embed
DROP FUNCTION IF EXISTS pgml."embed"(TEXT, TEXT, jsonb);
CREATE  FUNCTION pgml."embed"(
	"transformer" TEXT, /* &str */
	"text" TEXT, /* &str */
	"kwargs" jsonb DEFAULT '{}' /* pgrx::datum::json::JsonB */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'embed_wrapper';

-- src/api.rs:845
-- pgml::api::dump_all
DROP FUNCTION IF EXISTS pgml."dump_all"(TEXT);
CREATE  FUNCTION pgml."dump_all"(
	"path" TEXT /* &str */
) RETURNS void
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'dump_all_wrapper';

-- src/vectors.rs:276
-- pgml::vectors::dot_product
DROP FUNCTION IF EXISTS pgml."dot_product"(real[], real[]);
CREATE  FUNCTION pgml."dot_product"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"other" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'dot_product_s_wrapper';

-- src/vectors.rs:289
-- pgml::vectors::dot_product
DROP FUNCTION IF EXISTS pgml."dot_product"(double precision[], double precision[]);
CREATE  FUNCTION pgml."dot_product"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"other" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'dot_product_d_wrapper';

-- src/vectors.rs:104
-- pgml::vectors::divide
DROP FUNCTION IF EXISTS pgml."divide"(real[], real[]);
CREATE  FUNCTION pgml."divide"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"dividend" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'divide_vector_s_wrapper';

-- src/vectors.rs:114
-- pgml::vectors::divide
DROP FUNCTION IF EXISTS pgml."divide"(double precision[], double precision[]);
CREATE  FUNCTION pgml."divide"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"dividend" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'divide_vector_d_wrapper';

-- src/vectors.rs:34
-- pgml::vectors::divide
DROP FUNCTION IF EXISTS pgml."divide"(real[], real);
CREATE  FUNCTION pgml."divide"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"dividend" real /* f32 */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'divide_scalar_s_wrapper';

-- src/vectors.rs:39
-- pgml::vectors::divide
DROP FUNCTION IF EXISTS pgml."divide"(double precision[], double precision);
CREATE  FUNCTION pgml."divide"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"dividend" double precision /* f64 */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'divide_scalar_d_wrapper';

-- src/vectors.rs:254
-- pgml::vectors::distance_l2
DROP FUNCTION IF EXISTS pgml."distance_l2"(real[], real[]);
CREATE  FUNCTION pgml."distance_l2"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"other" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'distance_l2_s_wrapper';

-- src/vectors.rs:265
-- pgml::vectors::distance_l2
DROP FUNCTION IF EXISTS pgml."distance_l2"(double precision[], double precision[]);
CREATE  FUNCTION pgml."distance_l2"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"other" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'distance_l2_d_wrapper';

-- src/vectors.rs:234
-- pgml::vectors::distance_l1
DROP FUNCTION IF EXISTS pgml."distance_l1"(real[], real[]);
CREATE  FUNCTION pgml."distance_l1"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"other" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'distance_l1_s_wrapper';

-- src/vectors.rs:244
-- pgml::vectors::distance_l1
DROP FUNCTION IF EXISTS pgml."distance_l1"(double precision[], double precision[]);
CREATE  FUNCTION pgml."distance_l1"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"other" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'distance_l1_d_wrapper';

-- src/vectors.rs:302
-- pgml::vectors::cosine_similarity
DROP FUNCTION IF EXISTS pgml."cosine_similarity"(real[], real[]);
CREATE  FUNCTION pgml."cosine_similarity"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"other" real[] /* alloc::vec::Vec<f32> */
) RETURNS real /* f32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cosine_similarity_s_wrapper';

-- src/vectors.rs:318
-- pgml::vectors::cosine_similarity
DROP FUNCTION IF EXISTS pgml."cosine_similarity"(double precision[], double precision[]);
CREATE  FUNCTION pgml."cosine_similarity"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"other" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision /* f64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cosine_similarity_d_wrapper';

-- src/vectors.rs:44
-- pgml::vectors::add
DROP FUNCTION IF EXISTS pgml."add"(real[], real[]);
CREATE  FUNCTION pgml."add"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"addend" real[] /* alloc::vec::Vec<f32> */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'add_vector_s_wrapper';

-- src/vectors.rs:54
-- pgml::vectors::add
DROP FUNCTION IF EXISTS pgml."add"(double precision[], double precision[]);
CREATE  FUNCTION pgml."add"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"addend" double precision[] /* alloc::vec::Vec<f64> */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'add_vector_d_wrapper';

-- src/vectors.rs:4
-- pgml::vectors::add
DROP FUNCTION IF EXISTS pgml."add"(real[], real);
CREATE  FUNCTION pgml."add"(
	"vector" real[], /* alloc::vec::Vec<f32> */
	"addend" real /* f32 */
) RETURNS real[] /* alloc::vec::Vec<f32> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'add_scalar_s_wrapper';

-- src/vectors.rs:9
-- pgml::vectors::add
DROP FUNCTION IF EXISTS pgml."add"(double precision[], double precision);
CREATE  FUNCTION pgml."add"(
	"vector" double precision[], /* alloc::vec::Vec<f64> */
	"addend" double precision /* f64 */
) RETURNS double precision[] /* alloc::vec::Vec<f64> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'add_scalar_d_wrapper';

-- src/api.rs:19
-- pgml::api::activate_venv
DROP FUNCTION IF EXISTS pgml."activate_venv"(text);
CREATE  FUNCTION pgml."activate_venv"(
	"venv" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'activate_venv_wrapper';

-- src/api.rs:522
-- pgml::api::snapshot
DROP FUNCTION IF EXISTS pgml."snapshot"(text, text, real, pgml.Sampling, jsonb);
CREATE  FUNCTION pgml."snapshot"(
	"relation_name" TEXT, /* &str */
	"y_column_name" TEXT, /* &str */
	"test_size" real DEFAULT 0.25, /* f32 */
	"test_sampling" pgml.Sampling DEFAULT 'last', /* pgml::orm::sampling::Sampling */
	"preprocess" jsonb DEFAULT '{}' /* pgrx::datum::json::JsonB */
) RETURNS TABLE (
	"relation" TEXT,  /* alloc::string::String */
	"y_column_name" TEXT  /* alloc::string::String */
)
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'snapshot_wrapper';

-- src/api.rs:626
-- pgml::api::tune
DROP FUNCTION IF EXISTS pgml."tune"(text, text, text, text, text, jsonb, real, pgml.Sampling, bool, bool);
CREATE  FUNCTION pgml."tune"(
	"project_name" TEXT, /* &str */
	"task" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"relation_name" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"y_column_name" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"model_name" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"hyperparams" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"test_size" real DEFAULT 0.25, /* f32 */
	"test_sampling" pgml.Sampling DEFAULT 'last', /* pgml::orm::sampling::Sampling */
	"automatic_deploy" bool DEFAULT true, /* core::option::Option<bool> */
	"materialize_snapshot" bool DEFAULT false /* bool */
) RETURNS TABLE (
	"status" TEXT,  /* alloc::string::String */
	"task" TEXT,  /* alloc::string::String */
	"algorithm" TEXT,  /* alloc::string::String */
	"deployed" bool  /* bool */
)
PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'tune_wrapper';

-- src/api.rs:115
-- pgml::api::train
DROP FUNCTION IF EXISTS pgml."train"(text, text, text, text, pgml.Algorithm, jsonb, pgml.Search, jsonb, jsonb, real, pgml.Sampling, pgml.Runtime, bool, bool, jsonb);
CREATE  FUNCTION pgml."train"(
	"project_name" TEXT, /* &str */
	"task" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"relation_name" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"y_column_name" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"algorithm" pgml.Algorithm DEFAULT 'linear', /* pgml::orm::algorithm::Algorithm */
	"hyperparams" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"search" pgml.Search DEFAULT NULL, /* core::option::Option<pgml::orm::search::Search> */
	"search_params" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"search_args" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"test_size" real DEFAULT 0.25, /* f32 */
	"test_sampling" pgml.Sampling DEFAULT 'last', /* pgml::orm::sampling::Sampling */
	"runtime" pgml.Runtime DEFAULT NULL, /* core::option::Option<pgml::orm::runtime::Runtime> */
	"automatic_deploy" bool DEFAULT true, /* core::option::Option<bool> */
	"materialize_snapshot" bool DEFAULT false, /* bool */
	"preprocess" jsonb DEFAULT '{}' /* pgrx::datum::json::JsonB */
) RETURNS TABLE (
	"project" TEXT,  /* alloc::string::String */
	"task" TEXT,  /* alloc::string::String */
	"algorithm" TEXT,  /* alloc::string::String */
	"deployed" bool  /* bool */
)
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'train_wrapper';

-- src/api.rs:161
-- pgml::api::train_joint
DROP FUNCTION IF EXISTS pgml."train_joint"(text, text, text, text[], pgml.Algorithm, jsonb, pgml.Search, jsonb, jsonb, real, pgml.Sampling, pgml.Runtime, bool, bool, jsonb);
CREATE  FUNCTION pgml."train_joint"(
	"project_name" TEXT, /* &str */
	"task" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"relation_name" TEXT DEFAULT NULL, /* core::option::Option<&str> */
	"y_column_name" TEXT[] DEFAULT NULL, /* core::option::Option<alloc::vec::Vec<alloc::string::String>> */
	"algorithm" pgml.Algorithm DEFAULT 'linear', /* pgml::orm::algorithm::Algorithm */
	"hyperparams" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"search" pgml.Search DEFAULT NULL, /* core::option::Option<pgml::orm::search::Search> */
	"search_params" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"search_args" jsonb DEFAULT '{}', /* pgrx::datum::json::JsonB */
	"test_size" real DEFAULT 0.25, /* f32 */
	"test_sampling" pgml.Sampling DEFAULT 'last', /* pgml::orm::sampling::Sampling */
	"runtime" pgml.Runtime DEFAULT NULL, /* core::option::Option<pgml::orm::runtime::Runtime> */
	"automatic_deploy" bool DEFAULT true, /* core::option::Option<bool> */
	"materialize_snapshot" bool DEFAULT false, /* bool */
	"preprocess" jsonb DEFAULT '{}' /* pgrx::datum::json::JsonB */
) RETURNS TABLE (
	"project" TEXT,  /* alloc::string::String */
	"task" TEXT,  /* alloc::string::String */
	"algorithm" TEXT,  /* alloc::string::String */
	"deployed" bool  /* bool */
)
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'train_joint_wrapper';

-- src/api.rs:317
-- pgml::api::deploy
DROP FUNCTION IF EXISTS pgml."deploy"(text, pgml.Strategy, pgml.Algorithm);
CREATE  FUNCTION pgml."deploy"(
	"project_name" TEXT, /* &str */
	"strategy" pgml.Strategy, /* pgml::orm::strategy::Strategy */
	"algorithm" pgml.Algorithm DEFAULT NULL /* core::option::Option<pgml::orm::algorithm::Algorithm> */
) RETURNS TABLE (
	"project" TEXT,  /* alloc::string::String */
	"strategy" TEXT,  /* alloc::string::String */
	"algorithm" TEXT  /* alloc::string::String */
)
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'deploy_wrapper';
