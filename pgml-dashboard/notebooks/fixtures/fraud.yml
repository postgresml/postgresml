- model: notebooks.notebook
  pk: 1
  fields:
    name: 'Tutorial 1: Real Time Fraud Detection'
    created_at: 2022-08-15 22:26:18.428227+00:00
    updated_at: 2022-08-15 22:26:18.428241+00:00
- model: notebooks.notebookcell
  pk: 31
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO PRODUCTS (emoji, name, price, perishable) \nVALUES\n  ('\U0001F4B0',
      '1oz gold bar', '$1999.99', false),\n  ('\U0001F4D5', 'a tale of 2 cities',
      '$19.99', false),\n  ('\U0001F96C', 'head of lettuce', '$1.99', true)\nRETURNING
      *;"
    rendering: null
    execution_time: null
    cell_number: 3
    version: 5
    deleted_at: null
- model: notebooks.notebookcell
  pk: 33
  fields:
    notebook: 1
    cell_type: 1
    contents: "Now that we're in business, our first customer has shown up, named
      Alice. She is a chef that owns a salad shop, so she is going to create an order
      for 1,000 \U0001F96C `head of lettuce`.\n\nOur ecommerce site will record `orders`
      and their `line_items` in our database with the following schema."
    rendering: "<article class=\"markdown-body\"><p>Now that we're in business, our
      first customer has shown up, named Alice. She is a chef that owns a salad shop,
      so she is going to create an order for 1,000 \U0001F96C <code>head of lettuce</code>.</p>\n<p>Our
      ecommerce site will record <code>orders</code> and their <code>line_items</code>
      in our database with the following schema.</p></article>"
    execution_time: null
    cell_number: 4
    version: 2
    deleted_at: null
- model: notebooks.notebookcell
  pk: 35
  fields:
    notebook: 1
    cell_type: 3
    contents: "CREATE TABLE products (\n  emoji
      TEXT PRIMARY KEY,\n  name TEXT,\n  price MONEY,\n  perishable BOOLEAN\n);"
    rendering: null
    execution_time: null
    cell_number: 2
    version: 9
    deleted_at: null
- model: notebooks.notebookcell
  pk: 36
  fields:
    notebook: 1
    cell_type: 1
    contents: 'Introduction

      ------------


      Most organizations have some risks that may be minimized using machine learning,
      by predicting the likelihood of negative outcomes before they happen. As long
      as you''re able to track the information leading up to the unfortunate events,
      there are many different machine learning algorithms that can tease out the
      correlations across multiple variables.


      One example of risk ecommerce companies face is credit card fraud with stolen
      credit cards. When the owner of the card sees charges they never authorized
      on their monthly statement, they''ll report these to the credit card company,
      and the charges will be reversed. The ecommerce company will lose the merchandise
      as well as shipping charges and labor costs. If a company receives too many
      chargebacks, not only will they incur expensive losses, but the credit card
      processors may remove them from the platorm, so it''s important they have some
      certainty about the owner of the cards identity and legitimate interests.


      In this notebook, we''ll demonstrate how a simplified ecommerce application
      might track customer orders, and use machine learning to detect chargeback risks
      in real time during checkout. The most important step in building any Machine
      Learning model is understanding the data. Knowing it''s structure, application
      use, and the full meaning for the business will allow us to create meaningful
      features and labels for our models. In this notebook, we''ve included a fair
      bit of SQL to implement logic that would normally be written at the application
      layer to help you build an intuition about the domain.


      **Contents**


      - Part 1: Ecommerce Application Data Model

      - Part 2: Structuring the Training Data

      - Part 3: Training a Model

      - Part 4: Adding More Features


      Part 1: Ecommerce Application Data Model

      --------------------------------

      We''ll build out a simple ecommerce schema, and populate it with some example
      data. First, our store needs some products to sell. Products have a name, their
      price, and other metadata, like whether or not they are perishable goods.'
    rendering: '<article class="markdown-body"><h2>Introduction</h2>

      <p>Most organizations have some risks that may be minimized using machine learning,
      by predicting the likelihood of negative outcomes before they happen. As long
      as you''re able to track the information leading up to the unfortunate events,
      there are many different machine learning algorithms that can tease out the
      correlations across multiple variables.</p>

      <p>One example of risk ecommerce companies face is credit card fraud with stolen
      credit cards. When the owner of the card sees charges they never authorized
      on their monthly statement, they''ll report these to the credit card company,
      and the charges will be reversed. The ecommerce company will lose the merchandise
      as well as shipping charges and labor costs. If a company receives too many
      chargebacks, not only will they incur expensive losses, but the credit card
      processors may remove them from the platorm, so it''s important they have some
      certainty about the owner of the cards identity and legitimate interests.</p>

      <p>In this notebook, we''ll demonstrate how a simplified ecommerce application
      might track customer orders, and use machine learning to detect chargeback risks
      in real time during checkout. The most important step in building any Machine
      Learning model is understanding the data. Knowing it''s structure, application
      use, and the full meaning for the business will allow us to create meaningful
      features and labels for our models. In this notebook, we''ve included a fair
      bit of SQL to implement logic that would normally be written at the application
      layer to help you build an intuition about the domain.</p>

      <p><strong>Contents</strong></p>

      <ul>

      <li>Part 1: Ecommerce Application Data Model</li>

      <li>Part 2: Structuring the Training Data</li>

      <li>Part 3: Training a Model</li>

      <li>Part 4: Adding More Features</li>

      </ul>

      <h2>Part 1: Ecommerce Application Data Model</h2>

      <p>We''ll build out a simple ecommerce schema, and populate it with some example
      data. First, our store needs some products to sell. Products have a name, their
      price, and other metadata, like whether or not they are perishable goods.</p></article>'
    execution_time: null
    cell_number: 1
    version: 4
    deleted_at: null
- model: notebooks.notebookcell
  pk: 37
  fields:
    notebook: 1
    cell_type: 1
    contents: ters
    rendering: <article class="markdown-body"><p>ters</p></article>
    execution_time: null
    cell_number: 5
    version: 1
    deleted_at: 2022-08-18 15:01:02.379644+00:00
- model: notebooks.notebookcell
  pk: 38
  fields:
    notebook: 1
    cell_type: 3
    contents: "CREATE TABLE orders (\n  id BIGSERIAL PRIMARY KEY,\n  customer_name
      TEXT\n);\n\nCREATE TABLE line_items (\n  id BIGSERIAL PRIMARY KEY,\n  order_id
      BIGINT,\n  product_emoji TEXT,\n  count INTEGER\n);"
    rendering: null
    execution_time: null
    cell_number: 5
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 39
  fields:
    notebook: 1
    cell_type: 1
    contents: Now that we have created the schema, we can record Alice's order
    rendering: <article class="markdown-body"><p>Now that we have created the schema,
      we can record Alice's order</p></article>
    execution_time: null
    cell_number: 6
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 40
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO orders (customer_name) VALUES ('Alice');\n\nINSERT INTO
      line_items (order_id, product_emoji, count) \nVALUES (\n  -- a query to find
      Alice's most recent order\n  (SELECT max(id) FROM orders WHERE customer_name
      = 'Alice'),\n  '\U0001F96C',\n  1000\n)\nRETURNING *;"
    rendering: null
    execution_time: null
    cell_number: 7
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 41
  fields:
    notebook: 1
    cell_type: 1
    contents: "\U0001F50E That inline subselect in #7 is a little weird.\n\n```sql\n--
      a query to find Alice's most recent order\n(SELECT max(id) FROM orders WHERE
      customer_name = 'Alice')\n```\n\nTypically this ID would be passed in from the
      application layer, instead of being retrieved during the INSERT statement itself.
      But anyway... \n\nNext, we'll record her payment in full via credit card in
      our `payments` table."
    rendering: "<article class=\"markdown-body\"><p>\U0001F50E That inline subselect
      in #7 is a little weird.</p>\n<pre><code class=\"language-sql\">-- a query to
      find Alice's most recent order\n(SELECT max(id) FROM orders WHERE customer_name
      = 'Alice')\n</code></pre>\n<p>Typically this ID would be passed in from the
      application layer, instead of being retrieved during the INSERT statement itself.
      But anyway... </p>\n<p>Next, we'll record her payment in full via credit card
      in our <code>payments</code> table.</p></article>"
    execution_time: null
    cell_number: 8
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 42
  fields:
    notebook: 1
    cell_type: 3
    contents: "CREATE TABLE payments (\n  id BIGSERIAL PRIMARY KEY,\n  order_id BIGINT,\n
      \ amount MONEY\n);"
    rendering: null
    execution_time: null
    cell_number: 9
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 43
  fields:
    notebook: 1
    cell_type: 1
    contents: We'll be doing a little bit of heavy lifting in the next query to calculate
      her payment total on the fly.
    rendering: <article class="markdown-body"><p>We'll be doing a little bit of heavy
      lifting in the next query to calculate her payment total on the fly.</p></article>
    execution_time: null
    cell_number: 10
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 44
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO payments (order_id, amount) \n-- a query to compute the
      full amount of Alice's most recent order\nSELECT order_id, sum(count * price)
      AS amount\nFROM orders\nJOIN line_items ON line_items.order_id = orders.id\nJOIN
      products ON products.emoji = line_items.product_emoji\nWHERE orders.id = (SELECT
      max(id) AS order_id FROM orders WHERE customer_name = 'Alice')\nGROUP BY 1\nRETURNING
      *;"
    rendering: null
    execution_time: null
    cell_number: 11
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 45
  fields:
    notebook: 1
    cell_type: 1
    contents: "\U0001F389 Time to celebrate! Alice has paid in full for our first
      order, and business is good.\n\n\nNow, along comes Bob \"the bad guy\" who places
      an order for a \U0001F4B0 1oz gold bar."
    rendering: "<article class=\"markdown-body\"><p>\U0001F389 Time to celebrate!
      Alice has paid in full for our first order, and business is good.</p>\n<p>Now,
      along comes Bob \"the bad guy\" who places an order for a \U0001F4B0 1oz gold
      bar.</p></article>"
    execution_time: null
    cell_number: 12
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 46
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO orders (customer_name) VALUES ('Bob');\nINSERT INTO line_items
      (order_id, product_emoji, count) VALUES (\n  (SELECT max(id) FROM orders WHERE
      customer_name = 'Bob'),\n  '\U0001F4B0',\n  1\n)\nRETURNING *;"
    rendering: null
    execution_time: null
    cell_number: 13
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 47
  fields:
    notebook: 1
    cell_type: 1
    contents: Unfortunately, Bob makes his payment with a stolen credit card, but
      we don't know that yet.
    rendering: <article class="markdown-body"><p>Unfortunately, Bob makes his payment
      with a stolen credit card, but we don't know that yet.</p></article>
    execution_time: null
    cell_number: 14
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 48
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO payments (order_id, amount) \n-- a query to compute the
      full amount of Bob's most recent order\nSELECT order_id, sum(count * price)
      AS amount\nFROM orders\nJOIN line_items ON line_items.order_id = orders.id\nJOIN
      products ON products.emoji = line_items.product_emoji\nWHERE orders.id = (SELECT
      max(id) AS order_id FROM orders WHERE customer_name = 'Bob')\nGROUP BY 1\nRETURNING
      *;"
    rendering: null
    execution_time: null
    cell_number: 15
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 49
  fields:
    notebook: 1
    cell_type: 1
    contents: At the end of the month, the credit card company lets us know about
      the chargeback from the real card owner.  We'll need to create another table
      to keep track of this.
    rendering: <article class="markdown-body"><p>At the end of the month, the credit
      card company lets us know about the chargeback from the real card owner.  We'll
      need to create another table to keep track of this.</p></article>
    execution_time: null
    cell_number: 16
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 50
  fields:
    notebook: 1
    cell_type: 3
    contents: "CREATE TABLE chargebacks (\n  id BIGSERIAL PRIMARY KEY,\n  payment_id
      BIGINT\n)"
    rendering: null
    execution_time: null
    cell_number: 17
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 51
  fields:
    notebook: 1
    cell_type: 1
    contents: And now we can record the example of fraud
    rendering: <article class="markdown-body"><p>And now we can record the example
      of fraud</p></article>
    execution_time: null
    cell_number: 18
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 52
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO chargebacks (payment_id) \nSELECT max(payments.id) AS payment_id\nFROM
      payments \nJOIN orders ON payments.order_id = orders.id \nWHERE customer_name
      = 'Bob'\nRETURNING *;"
    rendering: null
    execution_time: null
    cell_number: 19
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 53
  fields:
    notebook: 1
    cell_type: 1
    contents: "\U0001F3C1 Congratulations! \U0001F3C1 \n----------------\nIf you've
      made it this far, you've won half the machine learning battle. We have created
      2 training data examples that are perfect for \"supervised\" machine learning.
      The chargebacks acts as the ground truth to inform the machine learning algorithm
      of whether or not an order is fraudulent. These records are what we refer to
      as \"labels\", a.k.a \"targets\" or \"Y-values\" for the data.\n\nPart 2: Structuring
      the Training Data\n--------------------------\nWe can construct a query that
      provides a summary view of our orders, including the fraudulent label."
    rendering: "<article class=\"markdown-body\"><h2>\U0001F3C1 Congratulations! \U0001F3C1</h2>\n<p>If
      you've made it this far, you've won half the machine learning battle. We have
      created 2 training data examples that are perfect for \"supervised\" machine
      learning. The chargebacks acts as the ground truth to inform the machine learning
      algorithm of whether or not an order is fraudulent. These records are what we
      refer to as \"labels\", a.k.a \"targets\" or \"Y-values\" for the data.</p>\n<h2>Part
      2: Structuring the Training Data</h2>\n<p>We can construct a query that provides
      a summary view of our orders, including the fraudulent label.</p></article>"
    execution_time: null
    cell_number: 20
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 54
  fields:
    notebook: 1
    cell_type: 3
    contents: "CREATE VIEW orders_summaries AS\nSELECT \n  orders.id AS order_id,
      \n  orders.customer_name,\n  payments.amount AS total, \n  ARRAY_AGG(products.emoji)
      AS product_emojis,\n  CASE WHEN chargebacks.id IS NOT NULL \n    THEN true \n
      \   ELSE false \n  END AS fraudulent\nFROM orders\nLEFT JOIN payments ON payments.order_id
      = orders.id\nLEFT JOIN chargebacks ON chargebacks.payment_id = payments.id\nLEFT
      JOIN line_items ON line_items.order_id = orders.id\nLEFT JOIN products ON products.emoji
      = line_items.product_emoji\nGROUP BY 1, 2, 3, 5\nORDER BY orders.id;"
    rendering: null
    execution_time: null
    cell_number: 21
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 55
  fields:
    notebook: 1
    cell_type: 1
    contents: Now, let's have a look at the summary
    rendering: <article class="markdown-body"><p>Now, let's have a look at the summary</p></article>
    execution_time: null
    cell_number: 22
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 56
  fields:
    notebook: 1
    cell_type: 3
    contents: SELECT * FROM orders_summaries;
    rendering: null
    execution_time: null
    cell_number: 23
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 57
  fields:
    notebook: 1
    cell_type: 1
    contents: It's intuitive that thieves will be more attracted to gold bars, than
      a head of lettuce because the resell value is better. Perishable goods are more
      difficult to move on the black market. A good piece of informationfor our model
      would be the percentage of the order that is perishable. We call this a "feature"
      of the data model. We can construct a query to return this feature for each
      order, along with the chargeback label.
    rendering: <article class="markdown-body"><p>It's intuitive that thieves will
      be more attracted to gold bars, than a head of lettuce because the resell value
      is better. Perishable goods are more difficult to move on the black market.
      A good piece of informationfor our model would be the percentage of the order
      that is perishable. We call this a "feature" of the data model. We can construct
      a query to return this feature for each order, along with the chargeback label.</p></article>
    execution_time: null
    cell_number: 24
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 58
  fields:
    notebook: 1
    cell_type: 3
    contents: "CREATE VIEW fraud_samples AS\nSELECT \n  SUM(CASE WHEN products.perishable
      THEN (count * price) ELSE '$0.0' END) / SUM(payments.amount) AS perishable_percentage,
      \n  CASE WHEN chargebacks.id IS NOT NULL \n    THEN true \n    ELSE false \n
      \ END AS fraudulent\nFROM orders\nLEFT JOIN payments ON payments.order_id =
      orders.id\nLEFT JOIN chargebacks ON chargebacks.payment_id = payments.id\nLEFT
      JOIN line_items ON line_items.order_id = orders.id\nLEFT JOIN products ON products.emoji
      = line_items.product_emoji\nGROUP BY orders.id, chargebacks.id\nORDER BY orders.id;"
    rendering: null
    execution_time: null
    cell_number: 25
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 59
  fields:
    notebook: 1
    cell_type: 3
    contents: SELECT * FROM fraud_samples;
    rendering: null
    execution_time: null
    cell_number: 26
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 60
  fields:
    notebook: 1
    cell_type: 1
    contents: 'Training a model

      ----------------


      This is a great training set for a machine learning model. We''ve found a feature
      `perishable_percentage` that perfectly correlates with the label `fraudulent`.
      Perishable orders are less likely to result in a chargeback. A good model will
      be able to generalize from the example data we have to new examples that we
      may never have seen before, like an order that is only 33% perishable goods.
      Now that we have a `VIEW` of this data, we can train a "classification" model
      to classify the features as `fraudulent` or not.'
    rendering: '<article class="markdown-body"><h2>Training a model</h2>

      <p>This is a great training set for a machine learning model. We''ve found a
      feature <code>perishable_percentage</code> that perfectly correlates with the
      label <code>fraudulent</code>. Perishable orders are less likely to result in
      a chargeback. A good model will be able to generalize from the example data
      we have to new examples that we may never have seen before, like an order that
      is only 33% perishable goods. Now that we have a <code>VIEW</code> of this data,
      we can train a "classification" model to classify the features as <code>fraudulent</code>
      or not.</p></article>'
    execution_time: null
    cell_number: 27
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 61
  fields:
    notebook: 1
    cell_type: 3
    contents: "SELECT * FROM pgml.train(\n  project_name => 'Our Fraud Model', --
      a friendly name we'll use to identify this machine learning project\n  task
      => 'classification', -- we want to classify into true or false\n  relation_name
      => 'fraud_samples', -- our view of the data\n  y_column_name => 'fraudulent'
      -- the \"labels\"\n);"
    rendering: null
    execution_time: null
    cell_number: 28
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 62
  fields:
    notebook: 1
    cell_type: 1
    contents: 'Oops. We''re going to get an error:


      ```

      ERROR:  ValueError: This solver needs samples of at least 2 classes in the data,
      but the data contains only one class: False

      ```


      Wait a second, we know there is both a True and a False label, because we have
      an example of both a fraudulent and legit order. What gives? This is a glimpse
      into how PostgresML works inside the black box. It splits the sample data into
      2 sets. One is used for training the model as we expected, and the other is
      used to test the model''s predictions against the remaining known labels. This
      way we can see how well the model generalizes. In this case, since there are
      only 2 data samples, 1 is used for training (the False label) and 1 is used
      for testing (the True label). Now we can understand there isn''t enough data
      to actually train and test. We need to generate a couple more examples so we
      have enough to train and test.'
    rendering: '<article class="markdown-body"><p>Oops. We''re going to get an error:</p>

      <pre><code>ERROR:  ValueError: This solver needs samples of at least 2 classes
      in the data, but the data contains only one class: False

      </code></pre>

      <p>Wait a second, we know there is both a True and a False label, because we
      have an example of both a fraudulent and legit order. What gives? This is a
      glimpse into how PostgresML works inside the black box. It splits the sample
      data into 2 sets. One is used for training the model as we expected, and the
      other is used to test the model''s predictions against the remaining known labels.
      This way we can see how well the model generalizes. In this case, since there
      are only 2 data samples, 1 is used for training (the False label) and 1 is used
      for testing (the True label). Now we can understand there isn''t enough data
      to actually train and test. We need to generate a couple more examples so we
      have enough to train and test.</p></article>'
    execution_time: null
    cell_number: 29
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 63
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO orders (customer_name) VALUES ('Carol');\nINSERT INTO line_items
      (\n  order_id, \n  product_emoji, \n  count\n) VALUES (\n  (SELECT max(id) FROM
      orders WHERE customer_name = 'Carol'),\n  '\U0001F4D5',\n  10\n)\nRETURNING
      *;"
    rendering: null
    execution_time: null
    cell_number: 30
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 64
  fields:
    notebook: 1
    cell_type: 1
    contents: Carol has bought a book, and now will legitimately pay in full.
    rendering: <article class="markdown-body"><p>Carol has bought a book, and now
      will legitimately pay in full.</p></article>
    execution_time: null
    cell_number: 31
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 65
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO payments (order_id, amount) \n-- a query to compute the
      full amount of Bob's most recent order\nSELECT order_id, sum(count * price)
      AS amount\nFROM orders\nJOIN line_items ON line_items.order_id = orders.id\nJOIN
      products ON products.emoji = line_items.product_emoji\nWHERE orders.id = (SELECT
      max(id) AS order_id FROM orders WHERE customer_name = 'Carol')\nGROUP BY 1\nRETURNING
      *;"
    rendering: null
    execution_time: null
    cell_number: 32
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 66
  fields:
    notebook: 1
    cell_type: 1
    contents: 'And now Dan (another fraudster) shows up to steal more books:'
    rendering: <article class="markdown-body"><p>And now Dan (another fraudster) shows
      up to steal more books:</p></article>
    execution_time: null
    cell_number: 33
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 67
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO orders (customer_name) VALUES ('Dan');\nINSERT INTO line_items
      (\n  order_id, \n  product_emoji, \n  count\n) VALUES (\n  (SELECT max(id) FROM
      orders WHERE customer_name = 'Dan'),\n  '\U0001F4D5',\n  50\n)\nRETURNING *;"
    rendering: null
    execution_time: null
    cell_number: 34
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 68
  fields:
    notebook: 1
    cell_type: 1
    contents: Here comes the fraudulent payment.
    rendering: <article class="markdown-body"><p>Here comes the fraudulent payment.</p></article>
    execution_time: null
    cell_number: 35
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 69
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO payments (order_id, amount) \n-- a query to compute the
      full amount of Bob's most recent order\nSELECT order_id, sum(count * price)
      AS amount\nFROM orders\nJOIN line_items ON line_items.order_id = orders.id\nJOIN
      products ON products.emoji = line_items.product_emoji\nWHERE orders.id = (SELECT
      max(id) AS order_id FROM orders WHERE customer_name = 'Dan')\nGROUP BY 1\nRETURNING
      *;"
    rendering: null
    execution_time: null
    cell_number: 36
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 70
  fields:
    notebook: 1
    cell_type: 1
    contents: And when the credit card company let's us know about the issue, we'll
      record it.
    rendering: <article class="markdown-body"><p>And when the credit card company
      let's us know about the issue, we'll record it.</p></article>
    execution_time: null
    cell_number: 37
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 71
  fields:
    notebook: 1
    cell_type: 3
    contents: "INSERT INTO chargebacks (payment_id) \nSELECT max(payments.id) AS payment_id\nFROM
      payments \nJOIN orders ON payments.order_id = orders.id \nWHERE customer_name
      = 'Dan'\nRETURNING *;"
    rendering: null
    execution_time: null
    cell_number: 38
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 72
  fields:
    notebook: 1
    cell_type: 1
    contents: And now we can try to train the model again.
    rendering: <article class="markdown-body"><p>And now we can try to train the model
      again.</p></article>
    execution_time: null
    cell_number: 39
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 73
  fields:
    notebook: 1
    cell_type: 3
    contents: "SELECT * FROM pgml.train(\n  project_name => 'Our Fraud Classification',
      -- a friendly name we'll use to identify this machine learning project\n  task
      => 'classification', -- we want to classify into true or false\n  relation_name
      => 'fraud_samples', -- our view of the data\n  y_column_name => 'fraudulent',
      -- the \"labels\"\n  test_size => 0.5 -- use half the data for testing rather
      than the default test size of 25%\n);"
    rendering: null
    execution_time: null
    cell_number: 40
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 74
  fields:
    notebook: 1
    cell_type: 1
    contents: "\U0001F3C1 Success! \U0001F3C1\n--------------\n\nWe can demonstrate
      basic usage of the model with another SQL call"
    rendering: "<article class=\"markdown-body\"><h2>\U0001F3C1 Success! \U0001F3C1</h2>\n<p>We
      can demonstrate basic usage of the model with another SQL call</p></article>"
    execution_time: null
    cell_number: 41
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 75
  fields:
    notebook: 1
    cell_type: 3
    contents: "SELECT perishable_percentage, fraudulent, pgml.predict('Our Fraud Classification',
      ARRAY[perishable_percentage]) AS predict_fraud \nFROM fraud_samples;"
    rendering: null
    execution_time: null
    cell_number: 42
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 76
  fields:
    notebook: 1
    cell_type: 1
    contents: Uh oh, the model was trained on a perfectly small dataset. It learned
      that unless the order is perishable goods, it's going to predict fraud 100%
      of the time, but our test data shows that's not 100% true. Let's generate some
      samples to further explore our model.
    rendering: <article class="markdown-body"><p>Uh oh, the model was trained on a
      perfectly small dataset. It learned that unless the order is perishable goods,
      it's going to predict fraud 100% of the time, but our test data shows that's
      not 100% true. Let's generate some samples to further explore our model.</p></article>
    execution_time: null
    cell_number: 43
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 77
  fields:
    notebook: 1
    cell_type: 3
    contents: "WITH exploration_samples AS (\n  SELECT generate_series(0, 1, 0.1)
      AS perishable_percentage\n)\nSELECT perishable_percentage, pgml.predict('Our
      Fraud Classification', ARRAY[perishable_percentage]) AS predict_fraud FROM exploration_samples;"
    rendering: null
    execution_time: null
    cell_number: 44
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 78
  fields:
    notebook: 1
    cell_type: 1
    contents: 'The default model is a linear regression, so it has learned from the
      training half of the data that high amounts of perishible goods make for safe
      orders.


      Part 4: Adding more features

      ----------------------------

      We need to add some more features to create a better model. Instead of just
      using the perishable percentage, we can use dollar values as our features, since
      we know criminals want to steal large amounts more than small amounts.'
    rendering: '<article class="markdown-body"><p>The default model is a linear regression,
      so it has learned from the training half of the data that high amounts of perishible
      goods make for safe orders.</p>

      <h2>Part 4: Adding more features</h2>

      <p>We need to add some more features to create a better model. Instead of just
      using the perishable percentage, we can use dollar values as our features, since
      we know criminals want to steal large amounts more than small amounts.</p></article>'
    execution_time: null
    cell_number: 45
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 79
  fields:
    notebook: 1
    cell_type: 3
    contents: "DROP VIEW fraud_samples;\nCREATE VIEW fraud_samples AS\nSELECT \n  SUM(CASE
      WHEN products.perishable THEN (count * price)::NUMERIC ELSE 0.0 END) AS perishable_amount,
      \n  SUM(CASE WHEN NOT products.perishable THEN (count * price)::NUMERIC ELSE
      0.0 END) AS non_perishable_amount, \n  CASE WHEN chargebacks.id IS NOT NULL
      \n    THEN true \n    ELSE false \n  END AS fraudulent\nFROM orders\nLEFT JOIN
      payments ON payments.order_id = orders.id\nLEFT JOIN chargebacks ON chargebacks.payment_id
      = payments.id\nLEFT JOIN line_items ON line_items.order_id = orders.id\nLEFT
      JOIN products ON products.emoji = line_items.product_emoji\nGROUP BY orders.id,
      chargebacks.id\nORDER BY orders.id;"
    rendering: null
    execution_time: null
    cell_number: 46
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 80
  fields:
    notebook: 1
    cell_type: 1
    contents: And now we retrain a new version of the model, by calling train with
      the same parameters again.
    rendering: <article class="markdown-body"><p>And now we retrain a new version
      of the model, by calling train with the same parameters again.</p></article>
    execution_time: null
    cell_number: 47
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 81
  fields:
    notebook: 1
    cell_type: 3
    contents: "SELECT * FROM pgml.train(\n  project_name => 'Our Fraud Classification',
      -- a friendly name we'll use to identify this machine learning project\n  task
      => 'classification', -- we want to classify into true or false\n  relation_name
      => 'fraud_samples', -- our view of the data\n  y_column_name => 'fraudulent',
      -- the \"labels\"\n  test_size => 0.5 -- use half the data for testing rather
      than the default test size of 25%\n);"
    rendering: null
    execution_time: null
    cell_number: 48
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 82
  fields:
    notebook: 1
    cell_type: 1
    contents: And then we can deploy this most recent version
    rendering: <article class="markdown-body"><p>And then we can deploy this most
      recent version</p></article>
    execution_time: null
    cell_number: 49
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 83
  fields:
    notebook: 1
    cell_type: 3
    contents: SELECT * FROM pgml.deploy('Our Fraud Classification', 'most_recent');
    rendering: null
    execution_time: null
    cell_number: 50
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 84
  fields:
    notebook: 1
    cell_type: 1
    contents: 'And view the input/outputs of this model based on our data:'
    rendering: <article class="markdown-body"><p>And view the input/outputs of this
      model based on our data:</p></article>
    execution_time: null
    cell_number: 51
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 85
  fields:
    notebook: 1
    cell_type: 3
    contents: "SELECT perishable_amount, non_perishable_amount, fraudulent, pgml.predict('Our
      Fraud Classification', ARRAY[perishable_amount, non_perishable_amount]) AS predict_fraud
      \nFROM fraud_samples;"
    rendering: null
    execution_time: null
    cell_number: 52
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 86
  fields:
    notebook: 1
    cell_type: 1
    contents: "This is the basic development cycle for a model. \n  \n1. Add new features\n2.
      Retrain the new model\n3. Analyze performance\n\nEven with a toy schema like
      this, it's possible to create many different features over the data. Examples
      of other statistcal features we could add:\n\n- How many orders the customer
      has previously made without chargebacks\n- What has their total spend been so
      far\n- How old is this account\n- What is their average order size\n- How frequently
      do they typically order\n- Do they typically by perishible or non perishable
      goods\n\nWe can create additional VIEWs, Sub SELECTs or [Common Table Expressions](https://www.postgresql.org/docs/current/queries-with.html)
      to standardize these features across models or reports.\n\nSub SELECTs may be
      preferable to Common Table Expressions for generating complex features, because
      CTEs create an optimization gate that prevents the query planner from pushing
      predicates down, which will hurt performance if you intend to reuse this VIEW
      during inference for a single row.\n\nIf you're querying a particular view frequently
      that is expensive to produce, you may consider using a `MATERILIZE VIEW`, to
      cache the results.\n\n\n```sql\n-- A sub select\nLEFT JOIN (\n  SELECT DISTINCT
      orders.customer_name, COUNT(*) AS previous_orders FROM ORDERS\n) AS customer_stats\n
      \ ON customer_stats.customer_name = orders.customer_name\n```\n\n```sql\n--
      A view\nCREATE VIEW customer_stats AS \nSELECT DISTINCT orders.customer_name,
      COUNT(*) AS previous_orders FROM ORDERS;\n\n...\nLEFT JOIN customer_stats ON
      customer_stats.customer_name = orders.customer_name\n```\n\n```sql\n-- A Common
      Table Expression\nWITH customer_stats AS ( \n  SELECT DISTINCT orders.customer_name,
      COUNT(*) AS previous_orders FROM ORDERS;\n)\n\n...\nLEFT JOIN customer_stats
      ON customer_stats.customer_name = orders.customer_name\n```"
    rendering: "<article class=\"markdown-body\"><p>This is the basic development
      cycle for a model. </p>\n<ol>\n<li>Add new features</li>\n<li>Retrain the new
      model</li>\n<li>Analyze performance</li>\n</ol>\n<p>Even with a toy schema like
      this, it's possible to create many different features over the data. Examples
      of other statistcal features we could add:</p>\n<ul>\n<li>How many orders the
      customer has previously made without chargebacks</li>\n<li>What has their total
      spend been so far</li>\n<li>How old is this account</li>\n<li>What is their
      average order size</li>\n<li>How frequently do they typically order</li>\n<li>Do
      they typically by perishible or non perishable goods</li>\n</ul>\n<p>We can
      create additional VIEWs, Sub SELECTs or <a href=\"https://www.postgresql.org/docs/current/queries-with.html\">Common
      Table Expressions</a> to standardize these features across models or reports.</p>\n<p>Sub
      SELECTs may be preferable to Common Table Expressions for generating complex
      features, because CTEs create an optimization gate that prevents the query planner
      from pushing predicates down, which will hurt performance if you intend to reuse
      this VIEW during inference for a single row.</p>\n<p>If you're querying a particular
      view frequently that is expensive to produce, you may consider using a <code>MATERILIZE
      VIEW</code>, to cache the results.</p>\n<pre><code class=\"language-sql\">--
      A sub select\nLEFT JOIN (\n  SELECT DISTINCT orders.customer_name, COUNT(*)
      AS previous_orders FROM ORDERS\n) AS customer_stats\n  ON customer_stats.customer_name
      = orders.customer_name\n</code></pre>\n<pre><code class=\"language-sql\">--
      A view\nCREATE VIEW customer_stats AS \nSELECT DISTINCT orders.customer_name,
      COUNT(*) AS previous_orders FROM ORDERS;\n\n...\nLEFT JOIN customer_stats ON
      customer_stats.customer_name = orders.customer_name\n</code></pre>\n<pre><code
      class=\"language-sql\">-- A Common Table Expression\nWITH customer_stats AS
      ( \n  SELECT DISTINCT orders.customer_name, COUNT(*) AS previous_orders FROM
      ORDERS;\n)\n\n...\nLEFT JOIN customer_stats ON customer_stats.customer_name
      = orders.customer_name\n</code></pre></article>"
    execution_time: null
    cell_number: 53
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 87
  fields:
    notebook: 1
    cell_type: 1
    contents: When you're out of ideas for features that might help the model distinguish
      orders that are likely to result in chargebacks, you may want to start testing
      different algorithms to see how the performance changes. PostgresML makes algorithm
      selection as easy as passing an additional parameter to `pgml.train`. You may
      want to test them all just to see, but `xgboost` typically gives excellent performance
      in terms of both accuracy and latency.
    rendering: <article class="markdown-body"><p>When you're out of ideas for features
      that might help the model distinguish orders that are likely to result in chargebacks,
      you may want to start testing different algorithms to see how the performance
      changes. PostgresML makes algorithm selection as easy as passing an additional
      parameter to <code>pgml.train</code>. You may want to test them all just to
      see, but <code>xgboost</code> typically gives excellent performance in terms
      of both accuracy and latency.</p></article>
    execution_time: null
    cell_number: 54
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 88
  fields:
    notebook: 1
    cell_type: 3
    contents: "SELECT * FROM pgml.train(\n  project_name => 'Our Fraud Classification',
      -- a friendly name we'll use to identify this machine learning project\n  task
      => 'classification', -- we want to classify into true or false\n  relation_name
      => 'fraud_samples', -- our view of the data\n  y_column_name => 'fraudulent',
      -- the \"labels\"\n  algorithm => 'xgboost', -- tree based models like xgboost
      are often the best performers for tabular data at scale\n  test_size => 0.5
      -- use half the data for testing rather than the default test size of 25%\n);"
    rendering: null
    execution_time: null
    cell_number: 55
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 89
  fields:
    notebook: 1
    cell_type: 1
    contents: 'Using Regression instead of Classificaiton

      ------------------------------------------


      So far we''ve been training a classifier that gives us a binary 0 or 1 output
      to indicate likely fraud or not. If we''d like to refine our application response
      to the models predictions in a more nuanced way, say high/medium/low risk instead
      of binary, we can use "regression" instead of "classification" to predict a
      likelihood between 0 and 1, instead of binary.'
    rendering: '<article class="markdown-body"><h2>Using Regression instead of Classificaiton</h2>

      <p>So far we''ve been training a classifier that gives us a binary 0 or 1 output
      to indicate likely fraud or not. If we''d like to refine our application response
      to the models predictions in a more nuanced way, say high/medium/low risk instead
      of binary, we can use "regression" instead of "classification" to predict a
      likelihood between 0 and 1, instead of binary.</p></article>'
    execution_time: null
    cell_number: 56
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 90
  fields:
    notebook: 1
    cell_type: 3
    contents: "SELECT * FROM pgml.train(\n  project_name => 'Our Fraud Regression',
      -- a friendly name we'll use to identify this machine learning project\n  task
      => 'regression', -- predict the likelihood\n  relation_name => 'fraud_samples',
      -- our view of the data\n  y_column_name => 'fraudulent', -- the \"labels\"\n
      \ algorithm => 'xgboost', \n  test_size => 0.5 -- use half the data for testing
      rather than the default test size of 25%\n);"
    rendering: null
    execution_time: null
    cell_number: 57
    version: 1
    deleted_at: null
- model: notebooks.notebookcell
  pk: 91
  fields:
    notebook: 1
    cell_type: 1
    contents: At this point, the primary limitation of our model is the amount of
      data, the number of examples we have to train it on. Luckily, as time marches
      on, and data accumulates in the database, we can simply retrain this model with
      additional calls to `pgml.train` and watch it adjust as new information becomes
      available.
    rendering: <article class="markdown-body"><p>At this point, the primary limitation
      of our model is the amount of data, the number of examples we have to train
      it on. Luckily, as time marches on, and data accumulates in the database, we
      can simply retrain this model with additional calls to <code>pgml.train</code>
      and watch it adjust as new information becomes available.</p></article>
    execution_time: null
    cell_number: 58
    version: 1
    deleted_at: null
